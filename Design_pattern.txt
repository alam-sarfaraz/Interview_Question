---------------------------------------------------------------------------------------------------------------------------------------------------------------
In Java, SOLID principles are an object-oriented approach that are applied to software structure design. It is conceptualized by Robert C. Martin (also known as Uncle Bob). These five principles have changed the world of object-oriented programming, and also changed the way of writing software. It also ensures that the software is modular, easy to understand, debug, and refactor.

SOLID Acronym

S : Single Responsibility Principle (SRP)
O : Open closed Principle (OSP)
L : Liskov substitution Principle (LSP)
I : Interface Segregation Principle (ISP)
D : Dependency Inversion Principle (DIP)

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Single Responsibility Principle (SRP)
The single responsibility principle states that every Java class must perform a single functionality. Implementation of multiple functionalities in a single class mashup the code and if any modification is required may affect the whole class.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Open closed Principle (OSP)

The open-closed principle states that according to new requirements the module should be open for extension but closed for modification.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97 
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Liskov substitution Principle (LSP)

The Liskov Substitution Principle (LSP) was introduced by Barbara Liskov.

This means that every derived class should be substitutable for their parent class.

This means that every subclass or derived class should be substitutable for their base or parent class.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Interface Segregation Principle (ISP)

The principle states that the larger interfaces split into smaller ones. Because the implementation classes use only the methods that are required. We should not force the client to use the methods that they do not want to use.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Dependency Inversion Principle (DIP)
The primary goal of the Dependency Inversion Principle is to reduce the coupling between high-level and low-level modules in a software system.

OR
The principle states that we must use abstraction instead of concrete implementations. High-level modules should not depend on the low-level module but both should depend on the abstraction.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97
---------------------------------------------------------------------------------------------------------------------------------------------------------------

Design patterns

Design patterns are solutions to general problems that software developers faced during software development.
Or
A design pattern is a generic repeatable solution to a frequently occurring problem in software design that is used in software engineering.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Types of Design Patterns in Java
1 creational design patterns. 
2 structural design patterns.
3 behavioral design patterns.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Creational design patterns. 

Creational design patterns provide solutions to instantiate an Object in the best possible way for specific situations.

1 Singleton Method
2 Factory Method
3 Abstract Factory Method
4 Builder Method
5 Prototype Method

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Singleton Method : The singleton pattern restricts the instantiation of a Class and ensures that only one instance of the class exists in the Java Virtual Machine. The implementation of the singleton pattern has always been a controversial topic among developers.

Purpose of Singleton Class
The primary purpose of a java Singleton class is to restrict the limit of the number of object creations to only one. This often ensures that there is access control to resources, for example, socket or database connection.

1. Ensure that only one instance of the class exists.
2. Provide global access to that instance by
3. Declaring all constructors of the class to be private.
4. Providing a static method that returns a reference to the instance. The lazy initialization concept is used to write the static methods.
5. The instance is stored as a private static variable.
--------------------------------------------------------------------------------------------------------------------------------------------------------------

Forms of Singleton Class Pattern
There are two forms of singleton design patterns, which are:

Eager Instantiation: The object creation takes place at the load time.
Lazy Instantiation: The object creation is done according to the requirement.

--------------------------------------------------------------------------------------------------------------------------------------------------------------
public class Singleton {

	private static Singleton singleton;
   
	private Singleton() {

	}

	public static Singleton getInstance() {
		if (singleton == null) {
			synchronized (Singleton.class) {
				if (singleton == null) {
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}

	public static void main(String[] args) {
           Singleton singleton = Singleton.getInstance();
           System.err.println(singleton.hashCode());
           Singleton singleton1 = Singleton.getInstance();
           System.err.println(singleton1.hashCode());
           
	}

}


Example of Eager Instantiation.

public class EagerInitializedSingleton {

    private static final EagerInitializedSingleton instance = new EagerInitializedSingleton();

    // private constructor to avoid client applications using the constructor
    private EagerInitializedSingleton(){}

    public static EagerInitializedSingleton getInstance() {
        return instance;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Lazy Instantiation: The object creation is done according to the requirement.

public class LazyInitializedSingleton {

    private static LazyInitializedSingleton instance;

    private LazyInitializedSingleton(){}

    public static LazyInitializedSingleton getInstance() {
        if (instance == null) {
            instance = new LazyInitializedSingleton();
        }
        return instance;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------
How to break Singleton pattern

Using Reflection to destroy Singleton Pattern.

public class ReflectionSingletonTest {

    public static void main(String[] args) {
        EagerInitializedSingleton instanceOne = EagerInitializedSingleton.getInstance();
        EagerInitializedSingleton instanceTwo = null;
        try {
            Constructor[] constructors = EagerInitializedSingleton.class.getDeclaredConstructors();
            for (Constructor constructor : constructors) {
                // This code will destroy the singleton pattern
                constructor.setAccessible(true);
                instanceTwo = (EagerInitializedSingleton) constructor.newInstance();
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(instanceOne.hashCode());
        System.out.println(instanceTwo.hashCode());
    }

}

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Factory Method :
The factory design pattern is used when we have a superclass with multiple subclasses and based on input, we need to return one of the subclasses.

Factory Design Pattern Advantages

1 Factory design pattern provides approach to code for interface rather than implementation.
2 Factory pattern removes the instantiation of actual implementation classes from client code. Factory pattern makes our code more robust, less coupled and easy to extend. For example, we can easily change PC class implementation because client program is unaware of this.
3 Factory pattern provides abstraction between implementation and client classes through inheritance.

https://www.digitalocean.com/community/tutorials/factory-design-pattern-in-java
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Abstract Factory Design Pattern

If you are familiar with factory design pattern in java, you will notice that we have a single Factory class. This factory class returns different subclasses based on the input provided and factory class uses if-else or switch statement to achieve this. In the Abstract Factory pattern, we get rid of if-else block and have a factory class for each sub-class. Then an Abstract Factory class that will return the sub-class based on the input factory class. At first, it seems confusing but once you see the implementation, it’s really easy to grasp and understand the minor difference between Factory and Abstract Factory pattern. Like our factory pattern post, we will use the same superclass and sub-classes.

Abstract Factory Design Pattern Benefits

Abstract Factory design pattern provides approach to code for interface rather than implementation.
Abstract Factory pattern is “factory of factories” and can be easily extended to accommodate more products, for example we can add another sub-class Laptop and a factory LaptopFactory.
Abstract Factory pattern is robust and avoid conditional logic of Factory pattern.

https://www.digitalocean.com/community/tutorials/abstract-factory-design-pattern-in-java
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Builder pattern:

Builder pattern was introduced to solve some of the problems with Factory and Abstract Factory design patterns when the Object contains a lot of attributes. There are three major issues with Factory and Abstract Factory design patterns when the Object contains a lot of attributes.

1 Too Many arguments to pass from client program to the Factory class that can be error prone because most of the time, the type of arguments are same and from client side its hard to maintain the order of the argument.
2 Some of the parameters might be optional but in Factory pattern, we are forced to send all the parameters and optional parameters need to send as NULL.
3 If the object is heavy and its creation is complex, then all that complexity will be part of Factory classes that is confusing.

https://www.digitalocean.com/community/tutorials/builder-design-pattern-in-java
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Prototype Design Pattern :

It would be easy to understand prototype design pattern with an example. Suppose we have an Object that loads data from database. Now we need to modify this data in our program multiple times, so it’s not a good idea to create the Object using new keyword and load all the data again from database. The better approach would be to clone the existing object into a new object and then do the data manipulation. Prototype design pattern mandates that the Object which you are copying should provide the copying feature. It should not be done by any other class. However whether to use shallow or deep copy of the Object properties depends on the requirements and its a design decision.

https://www.digitalocean.com/community/tutorials/prototype-design-pattern-in-java#prototype-design-pattern-example
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Structural design patterns.
1 Adapter Method
2 Bridge Method
3 Composite Method
4 Decorator Method
5 Facade Method
6 Proxy Method
7 Flyweight Method

Behavioral design patterns.
1 Command Method
2 Iterator Method
3 Mediator Method
4 Memento Method
5 Observer method
6 State Method
7 Strategy Method
8 Template Method
9 Visitor Method
10 Null Object Method
