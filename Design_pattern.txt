What are the benefits of using design patterns?
Design patterns provide reusable, proven solutions to common software problems, improving code readability, maintainability, and scalability. They promote best practices like SOLID principles, reduce development effort, and enhance communication among developers by offering a common vocabulary (e.g., Singleton, Factory, Observer). Using them leads to faster development, fewer errors, and better collaboration in large-scale projects.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
In Java, SOLID principles are an object-oriented approach that are applied to software structure design. It is conceptualized by Robert C. Martin (also known as Uncle Bob). These five principles have changed the world of object-oriented programming, and also changed the way of writing software. It also ensures that the software is modular, easy to understand, debug, and refactor.

SOLID Acronym

S : Single Responsibility Principle (SRP)
O : Open closed Principle (OSP)
L : Liskov substitution Principle (LSP)
I : Interface Segregation Principle (ISP)
D : Dependency Inversion Principle (DIP)

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Single Responsibility Principle (SRP)
The single responsibility principle states that every Java class must perform a single functionality. Implementation of multiple functionalities in a single class mashup the code and if any modification is required may affect the whole class.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Open closed Principle (OSP)

The open-closed principle states that according to new requirements the module should be open for extension but closed for modification.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97 
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Liskov substitution Principle (LSP)

The Liskov Substitution Principle (LSP) was introduced by Barbara Liskov.

This means that every derived class should be substitutable for their parent class.

This means that every subclass or derived class should be substitutable for their base or parent class.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Interface Segregation Principle (ISP)

The principle states that the larger interfaces split into smaller ones. Because the implementation classes use only the methods that are required. We should not force the client to use the methods that they do not want to use.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Dependency Inversion Principle (DIP)
The primary goal of the Dependency Inversion Principle is to reduce the coupling between high-level and low-level modules in a software system.

OR
The principle states that we must use abstraction instead of concrete implementations. High-level modules should not depend on the low-level module but both should depend on the abstraction.

https://medium.com/@javatechie/solid-design-principle-java-ae96a48db97
---------------------------------------------------------------------------------------------------------------------------------------------------------------Design patterns
Design patterns are solutions to general problems that software developers faced during software development.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Types of Design Patterns in Java
1 creational design patterns. - Creational design patterns provide solutions to instantiate an Object in the best possible way for specific situations.
2 structural design patterns. - Organizing classes and objects to form larger structures.
3 behavioral design patterns. - These patterns help to define how the objects should communicate and interact with one another.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Creational design patterns. 

Creational design patterns provide solutions to instantiate an Object in the best possible way for specific situations.

1 Singleton Method
2 Factory Method
3 Abstract Factory Method
4 Builder Method
5 Prototype Method

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Singleton Method : The singleton pattern restricts the instantiation of a Class and ensures that only one instance of the class exists in the Java Virtual Machine.

Purpose of Singleton Class
The primary purpose of a java Singleton class is to restrict the limit of the number of object creations to only one. This often ensures that there is access control to resources, for example, socket or database connection.

1. Ensure that only one instance of the class exists.
2. Provide global access to that instance by
3. Declaring all constructors of the class to be private.
4. Providing a static method that returns a reference to the instance. The lazy initialization concept is used to write the static methods.
5. The instance is stored as a private static variable.

Why is it Important?
    Resource management: Prevents multiple instances of heavy resources (DB connections, loggers).
    Consistency: Ensures a single source of truth across the application.
    Performance: Reduces unnecessary object creation.
    Widely used in frameworks: Spring Beans (default scope), Runtime, Logger.
--------------------------------------------------------------------------------------------------------------------------------------------------------------

Forms of Singleton Class Pattern
There are two forms of singleton design patterns, which are:

Eager Instantiation: The object creation takes place at the load time.
Lazy Instantiation: The object creation is done according to the requirement.

--------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.inn.string;

import java.lang.reflect.Constructor;

public class SingletonExample {

    private static SingletonExample singleton;

    private SingletonExample() {
        // Uncomment this to prevent reflection breaking
        // if (singleton != null) {
        //     throw new RuntimeException("Use getInstance() method to create");
        // }
    }

    public static SingletonExample getInstance() {
        if (singleton == null) {
            synchronized (SingletonExample.class) {
                if (singleton == null) {
                    singleton = new SingletonExample();
                }
            }
        }
        return singleton;
    }

    public static void main(String[] args) throws Exception {
        SingletonExample obj1 = SingletonExample.getInstance();
        SingletonExample obj2 = SingletonExample.getInstance();
        System.out.println("Normal Singleton: " + (obj1 == obj2)); // true

        // Breaking singleton using Reflection
        Constructor<SingletonExample> constructor = SingletonExample.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        SingletonExample newInstance = constructor.newInstance();

        System.out.println("After Reflection: " + (obj1 == newInstance)); // false
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Factory Method 
The Factory Method Pattern provides an interface for creating objects in a superclass but allows subclasses to decide which class to instantiate.

Why is it Important?
    Encapsulates object creation logic.
    Promotes loose coupling and follows the Open/Closed Principle (OCP).
    Improves maintainability and scalability of the application.

https://www.digitalocean.com/community/tutorials/factory-design-pattern-in-java
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Abstract Factory Design Pattern

If you are familiar with factory design pattern in java, you will notice that we have a single Factory class. This factory class returns different subclasses based on the input provided and factory class uses if-else or switch statement to achieve this. In the Abstract Factory pattern, we get rid of if-else block and have a factory class for each sub-class. Then an Abstract Factory class that will return the sub-class based on the input factory class. At first, it seems confusing but once you see the implementation, it’s really easy to grasp and understand the minor difference between Factory and Abstract Factory pattern. Like our factory pattern post, we will use the same superclass and sub-classes.

Abstract Factory Design Pattern Benefits

Abstract Factory design pattern provides approach to code for interface rather than implementation.
Abstract Factory pattern is “factory of factories” and can be easily extended to accommodate more products, for example we can add another sub-class Laptop and a factory LaptopFactory.
Abstract Factory pattern is robust and avoid conditional logic of Factory pattern.

https://www.digitalocean.com/community/tutorials/abstract-factory-design-pattern-in-java
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Builder pattern:

Builder pattern was introduced to solve some of the problems with Factory and Abstract Factory design patterns when the Object contains a lot of attributes. There are three major issues with Factory and Abstract Factory design patterns when the Object contains a lot of attributes.

1 Too Many arguments to pass from client program to the Factory class that can be error prone because most of the time, the type of arguments are same and from client side its hard to maintain the order of the argument.
2 Some of the parameters might be optional but in Factory pattern, we are forced to send all the parameters and optional parameters need to send as NULL.
3 If the object is heavy and its creation is complex, then all that complexity will be part of Factory classes that is confusing.

https://www.digitalocean.com/community/tutorials/builder-design-pattern-in-java
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Prototype Design Pattern :

It would be easy to understand prototype design pattern with an example. Suppose we have an Object that loads data from database. Now we need to modify this data in our program multiple times, so it’s not a good idea to create the Object using new keyword and load all the data again from database. The better approach would be to clone the existing object into a new object and then do the data manipulation. Prototype design pattern mandates that the Object which you are copying should provide the copying feature. It should not be done by any other class. However whether to use shallow or deep copy of the Object properties depends on the requirements and its a design decision.

https://www.digitalocean.com/community/tutorials/prototype-design-pattern-in-java#prototype-design-pattern-example
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Structural design patterns.
1 Adapter Method
2 Bridge Method
3 Composite Method
4 Decorator Method
5 Facade Method
6 Proxy Method
7 Flyweight Method

Behavioral design patterns.
1 Command Method
2 Iterator Method
3 Mediator Method
4 Memento Method
5 Observer method
6 State Method
7 Strategy Method
8 Template Method
9 Visitor Method
10 Null Object Method
