You notice a delay when fetching millions of records through an endpoint in a Spring Boot application. How will you handle it?
1. Pagination
Instead of fetching all records at once, implement pagination to retrieve a subset of records in smaller chunks.
Implementation: Use Pageable with Spring Data JPA

2.Async / Batch Processing
If the client absolutely needs all data:
Process in background job (e.g., Spring Batch).
Store result in file (CSV/JSON) and give a download link.
Avoid locking up API for minutes.

3. Streaming Data
Stream the records to the client instead of loading them all into memory.
Normally, when you call findAll(), Spring JPA loads all records into memory first → very heavy for millions of rows.
With streaming, records are fetched from the database one by one (or in small chunks) and sent to the client as they come, instead of waiting for the full dataset.

4. Optimize Database Query
Ensure proper indexing on frequently queried columns.
Use lazy loading for relationships.
Optimize SQL queries by fetching only required columns.

5. Returning Compressed Data
To reduce payload size, compress the response using Gzip: Configure compression in application.properties:
server.compression.enabled=true
server.compression.mime-types=application/json
server.compression.min-response-size=1024
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Can read configuration from external files other than application.properties or application.yml.
Yes, Spring Boot supports external properties files, YAML files, environment variables, command-line args, or config servers, giving flexibility beyond application.properties.

1 Custom Properties/YAML File – Use @PropertySource("classpath:custom.properties") or file: for external files.
   @PropertySource("classpath:config/external.properties")
   @Configuration
   public class AppConfig { }

2 Environment Variables – Spring Boot automatically maps OS environment variables to properties.
3 Command-Line Arguments – Pass properties like --server.port=9090 when starting the app.
4 Spring Cloud Config – Centralized config server providing properties to multiple services.
5 Programmatic Loading – Load any file manually using Properties.load(new FileInputStream("/path/file.properties")).
   Properties props = new Properties();
   props.load(new FileInputStream("/path/config.properties"));

---------------------------------------------------------------------------------------------------------------------------------------------------------------
BeanFactory and ApplicationContext.
In Spring, both BeanFactory and ApplicationContext are IoC containers that manage beans.

BeanFactory is the basic container with lazy loading, while ApplicationContext is the advanced container with eager loading and enterprise features — and it’s the one we use in real projects, including Spring Boot.

Think of BeanFactory as the simplest version of Spring’s container — it just gives you beans when you ask, using lazy loading. But in real-world apps we need more — events, internationalization, AOP, and annotation support. That’s where ApplicationContext comes in; it eagerly loads beans at startup and provides all the enterprise features. That’s why in practice, especially with Spring Boot, we always use ApplicationContext.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
How do you optimize the startup time of a Spring Boot application in a production environment?
We can optimize Spring Boot startup in production by 
enabling lazy initialization,
excluding unused auto-configurations, 
using profiles,
limiting classpath scanning,
optimizing database initialization,
reducing logging overhead,
and leveraging Spring Native AOT compilation for near-instant startup.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you explain the complete request handling flow in Spring MVC, starting from when a client sends an HTTP request until the response is returned?
A Spring MVC request flows through Filters → DispatcherServlet → HandlerMapping → Interceptors → Controller → ViewResolver/MessageConverter → back through Interceptors & Filters → and finally to the client.

Filters are servlet components that intercept requests and responses, mainly used for cross-cutting concerns like logging, security, or encoding — they run before and after the servlet.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
DispatcherServlet
In Spring MVC, the DispatcherServlet acts as the front controller. It is responsible for receiving requests and sending them to the appropriate handler method in the controller. After the controller processes the request and returns the response, the DispatcherServlet takes it and forwards it to a ViewResolver to render the view (e.g., JSP or Thymeleaf template). If the response is in JSON format, the DispatcherServlet uses tools like Jackson to serialize the data and send it back to the client.

Role:
Receives the request.
Finds the right controller to handle it (via handler mappings).
Calls the controller method.
Returns the view or response to the client.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
What are Spring Interceptors?
Spring Interceptors are components in the Spring MVC framework that allow us to intercept HTTP requests and responses at three different stages of their lifecycle, before they reach the controller and after the view is rendered.    
Interceptor: Works at the Spring MVC level, after the DispatcherServlet has chosen the handler.  
To create an interceptor, you implement HandlerInterceptor or extend HandlerInterceptorAdapter

Key Responsibilities of Interceptors
   Pre-processing of requests (e.g., authentication, logging, input validation)
   Post-processing of responses (e.g., modifying the model, adding common attributes)
   After-completion tasks (e.g., cleaning up resources, logging performance metrics)
--------------------------------------------------------------------------------------------------------------------------------------------------------------
CSRF (Cross-Site Request Forgery) is an attack where a malicious site tricks a user’s browser into sending unwanted requests to your application (like transferring money, changing password, etc.) while the user is logged in.

Spring Security enables CSRF protection by default to prevent such attacks.

It usually works by requiring a special token (CSRF token) in every state-changing request (like POST, PUT, DELETE). If the token is missing or invalid → request is rejected.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the role of actuator in spring boot?
Actuator is a module in Spring Boot that provides ready-to-use features for monitoring and managing applications by exposing endpoints for health, metrics, info, logging, and more.

Implement Actuator in Spring Boot:
  1. Add Dependency
       <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
       </dependency>
  2. Enable Actuator Endpoints
      management:
	   endpoints:
		 web:
		   exposure:
             include: "*"
  3. Run and Access Endpoints
       http://localhost:8080/actuator/health → returns {"status":"UP"}
       http://localhost:8080/actuator/metrics/jvm.memory.used → shows JVM memory usage.

---------------------------------------------------------------------------------------------------------------------------------------------------------------
What are different types of Spring Bean autowiring?
There are four types of autowiring in Spring framework.

autowire byName
autowire byType
autowire by constructor
autowiring by @Autowired and @Qualifier annotations
---------------------------------------------------------------------------------------------------------------------------------------------------------------
What is lazy initialization of spring bean?
Lazy initialization in Spring means a bean is created only when it is first needed, instead of at application startup.

1 Normal (Eager) Initialization
By default, Spring creates all singleton beans at startup.
This makes them ready for use immediately but increases startup time and memory usage.

2 Lazy Initialization
Spring delays the creation of the bean until it’s actually requested.
This can make the application start faster if some beans are rarely used.

Example :
@Component
@Lazy
public class MyBean {
    public MyBean() {
        System.out.println("MyBean Created!");
    }
}

spring.main.lazy-initialization=true

Constructor Injection + Lazy Initialization
If you have constructor injection and mark a dependency as @Lazy,
Spring will inject a proxy instead of the real bean.
The real bean is only created when you first call a method on that dependency.

Field / Setter Injection + Lazy Initialization
Works the same way — Spring injects a proxy object.
The real bean will be created only on the first method call.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
What are the bean scopes available in Spring?
Singleton :  Only one instance per Spring container.Same object returned every time you request it.          
Prototype :  A new instance is created every time you request it.
Request   :  One bean instance per HTTP request.
Session   :  One bean instance per HTTP session. 
Application: One bean instance per ServletContext (shared across the whole app).
Websocket :  One bean instance per WebSocket session.           

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Explain the Bean Life Cycle in Spring ?

Below are the Spring Bean Life Cycle stages :
1 Loading Bean Definitions: Spring reads the configuration (XML, Java Configuration Classes or Java Annotations) to understand bean definitions, including their properties, dependencies and scope.

2 Bean Instantiation: Spring creates instances of the beans. Dependencies are injected via constructor, setter or field injection based on the defined configurations.

3 Bean Initialization: After instantiation and dependency injection, Spring performs initialization.
      This can be customized using:
      init() method in XML
      afterPropertiesSet() from the InitializingBean interface
      @PostConstruct annotation
4 Bean Usage: The fully initialized bean is now ready for use within the application. It can interact with other beans and components as needed.

5 Bean Destruction: When the application shuts down, Spring performs bean cleanup by calling:
                  Custom destroy() method (if defined in XML)
                  destroy() from the DisposableBean interface
                  @PreDestroy annotation.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
What is dependency Injection?

The process of injecting dependent bean objects into target bean objects is called dependency injection.

Setter Injection: The IOC container will inject the dependent bean object into the target bean object by calling the setter method.
Constructor Injection: The IOC container will inject the dependent bean object into the target bean object by calling the target bean constructor.
Field Injection: The IOC container will inject the dependent bean object into the target bean object by Reflection API.

Explain the difference between constructor and setter injection?

Constructor Injection
        Dependencies are provided at the time of object creation through the class constructor.
        Ensures that the bean is fully initialized with all required dependencies when it is created.
        Promotes immutability because dependencies cannot be changed after creation.
        Useful for mandatory dependencies.
        
Setter Injection
        Dependencies are provided after object creation via setter methods.
        Allows changing dependencies even after the bean is created (mutable).
        Useful for optional dependencies.
        If you forget to set a required dependency, the bean may still be created but fail later.
        
Which DI is Best and Why?
Constructor Injection (Preferred in most cases)
    Immutability: Dependencies cannot change after the microservice starts, which improves stability.
    Mandatory Dependencies: Microservices usually require well-defined, critical dependencies (databases, messaging queues, etc.) to function.
    Easier Testing: Encourages dependency injection through constructors, which integrates well with unit testing and frameworks like JUnit/Mockito.
    Fail Fast: If a mandatory dependency is missing, the microservice fails during startup rather than at runtime.

---------------------------------------------------------------------------------------------------------------------------------------------------------------

What is an IOC container?

Spring IoC Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle. It gets the information about the objects from a configuration file(XML) or Java Code or Java Annotations and Java POJO class. These objects are called Beans. Since the Controlling of Java objects and their lifecycle is not done by the developers, hence the name Inversion Of Control.                  

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring Boot:
Spring Boot is an open source Java-based framework used to create a stand alone application(micro Service).
Features of Spring Boot:

1 Creates stand-alone spring application with minimal configuration needed.
2 It has embaded server (tomcat and jetty) for run the application.
3 Spring Boot Actuator provides health check, metrics and monitors the endpoints of the application. It also simplifies the troubleshooting management.
4 Spring Boot automatically configures dependencies by using @EnableAutoconfiguration annotation and reduces boilerplate code.
5 Security – to provide authentication and authorization
6 Logging – to record events at certain points during program execution
---------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the use of Profiles in spring boot?
While developing the application we deal with multiple environments such as dev, QA, Prod, and each environment requires a different configuration. For eg., we might be using an embedded H2 database for dev but for prod, we might have proprietary Oracle or DB2. Even if DBMS is the same across the environment, the URLs will be different.

spring.profiles.active=dev

This will activate the dev profile, and Spring Boot will load the application-dev.properties.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Spring Boot dependency management?
Spring Boot dependency management is used to manage dependencies and configuration automatically without you specifying the version for any of that dependencies.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
How Spring Boot Application Works Internally?

The class has @SpringBootApplication and a main() method with SpringApplication.run().
This is where the magic starts.

1 Spring Boot starts Spring
       It creates a Spring Application Context (a container) to hold and manage all your beans (objects).

2 Auto-configuration kicks in
       Based on the libraries in your project (like Spring Web, JPA, Security), Spring Boot automatically configures necessary settings — you don’t have to write boilerplate code.

3 Component scanning
       It looks for classes with annotations like @Component, @Service, @Repository, @Controller in your package and creates bean objects for them.

4 Dependency Injection
       If a class needs another object, Spring Boot automatically provides it (instead of you creating it manually).

5 Embedded Server starts
       If it’s a web app, Spring Boot starts an embedded Tomcat/Jetty/Undertow server.
       Your controllers get mapped to URLs automatically.

6 Application is ready
       Spring Boot waits for requests (if it’s a web app) or starts processing tasks (if it’s a batch app).


Spring Boot runs your main class → creates a Spring container → auto-configures everything → injects dependencies → starts a server (if needed) → your app runs.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Api (Application Programming Interface)
API in Spring Boot is a set of RESTful endpoints defined in a Spring Boot application. These endpoints are created using annotations such as @RestController, @GetMapping, @PostMapping, and others. The API allows clients to interact with the application through HTTP requests, handling methods like GET, POST, PUT, and DELETE to perform operations and exchange data, typically in JSON format.
-------------------------------------------------------------------------------------------------------------------------------------------------------------

What do you understand by RESTful Web Services?
RESTful web services are services that follow REST architecture. REST stands for Representational State Transfer and uses HTTP protocol (web protocol) for implementation. These services are lightweight, provide maintainability, scalability, support communication among multiple applications that are developed using different programming languages. They provide means of accessing resources present at server required for the client via the web browser by means of request headers, request body, response body, status codes, etc.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
