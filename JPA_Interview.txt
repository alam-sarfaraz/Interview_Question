Difference between JPA Repository and CRUD Repository?
In Spring Data JPA, both CrudRepository and JpaRepository are interfaces that provide data access operations for entities.

CrudRepository
Methods provided: save(), findById(), findAll(), delete(), count(), existsById(), etc.
Use Case: When you only need simple CRUD operations without advanced JPA features.

JpaRepository
Purpose: Extends CrudRepository and PagingAndSortingRepository to provide: All CRUD methods,Paging & Sorting methods ,Additional JPA-specific features.
Extra Methods provided: findAll(Sort sort),findAll(Pageable pageable), flush(),saveAndFlush(),deleteInBatch(),getOne() (lazy fetch proxy).
Use Case: When you need pagination, sorting, and batch operations.

Diagram :

Repository
   ↑
CrudRepository
   ↑
PagingAndSortingRepository
   ↑
JpaRepository

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Explain the different JPA entity lifecycle states.

New / Transient
Managed / Persistent
Detached
Removed
--------------------------------------------------------------------------------------------------------------------------------------------------------------
How do you configure JPA in a Java application?

Two Common Ways to Configure JPA
1. Step
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>6.5.0.Final</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
</dependency>

2 Create persistence.xml (if not using Spring Boot)
   Located in META-INF/persistence.xml.if not exist then create in your classpath (usually src/main/resources/META-INF/).

3  Add your persistence unit configuration. (<persistence-unit name="myJpaUnit">)

EntityManagerFactory emf = Persistence.createEntityManagerFactory("myJpaUnit");
EntityManager em = emf.createEntityManager();

EntityManager em = JpaConfig.getEntityManager();
em.getTransaction().begin();
Employee emp = new Employee();
emp.setName("John");
emp.setSalary(50000);
em.persist(emp);

em.getTransaction().commit();
em.close();
________________________________________________________________________
2 Using application.properties or application.yml (Spring Boot)

1. Add Dependencies (Maven)
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>

2. Add Database Configuration in application.properties

spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password

spring.jpa.hibernate.ddl-auto=update   # create, update, validate, none
spring.jpa.show-sql=true               # Show SQL in console
spring.jpa.properties.hibernate.format_sql=true  # Make SQL readable

3. Create a Repository Interface
import org.springframework.data.jpa.repository.JpaRepository;

public interface EmployeeRepository extends JpaRepository<Employee, Long> {
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Embeddable class?
An Embeddable class in JPA is a value type class whose fields are mapped as part of another entity’s table instead of having its own table.
It is not an entity — it doesn’t have an @Id and cannot exist independently in the data.

@Embeddable
public class Address {
    private String street;
    private String city;
    private String zipcode;
}
@Entity
public class Customer {
    @Id
    private Long id;

    private String name;

    @Embedded
    private Address address; // Address fields stored in Customer table
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------
EntityManager: Manages the lifecycle of entity instances, performs CRUD operations, and executes queries. It is not thread-safe and should be used per transaction or per request.

EntityManagerFactory: A factory for creating `EntityManager` instances. It is thread-safe and expensive to create, so it should be created once per application and reused.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the purpose of `EntityTransaction`?
The `EntityTransaction` interface manages transaction boundaries. It allows you to begin, commit, and rollback transactions to ensure data consistency and integrity.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Describe in detail about the Persistence Unit in JPA?
In JPA, a Persistence Unit is basically the configuration block that tells JPA which database to connect to, which entities to manage, and how to manage them.
it Defined in persistence.xml (inside META-INF folder in your classpath).

Persistence Unit = “JPA’s configuration blueprint” for managing entities and database connections. It defines what to store, where to store it, and how to interact with it.

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Explain the difference between a shared cache mode and a local cache mode in JPA?
JPA uses caching to avoid hitting the database for the same data repeatedly.
There are two main types of 2nd-level cache behavior:

Shared Cache Mode → Uses the second-level cache so that cached entities are available to all EntityManagers in the application.Can be configured globally in persistence.xml using shared-cache-mode (e.g., ALL, ENABLE_SELECTIVE).

Local Cache Mode → Uses only the first-level cache (persistence context) inside a single EntityManager.Always enabled in JPA — you don’t need to configure it.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you use JPA to handle optimistic concurrency control? Can you explain how the EntityManager.lock() method works?

JPA provides a mechanism for optimistic concurrency control to handle situations where multiple transactions are trying to modify the same entity concurrently. In optimistic concurrency control, each transaction checks to see if any other transaction has modified the entity since it was last read. This is achieved by using a version field in the entity, which is incremented each time the entity is modified.

JPA provides the @Version annotation to indicate which field in the entity should be used as the version field. When an entity is persisted or updated, JPA automatically checks the current version of the entity in the database and compares it with the version in the entity being persisted or updated. If the versions do not match, a “javax.persistence.OptimisticLockException” is thrown, indicating that the entity has been modified by another transaction.

The EntityManager.lock() method allows you to specify the lock mode to use and the timeout for the lock. The lock mode can be either optimistic or pessimistic. With optimistic locking, the lock is released immediately after the transaction completes. With pessimistic locking, the lock is held until the transaction completes or the lock timeout expires.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the purpose of the @Version annotation in JPA? How is it used in optimistic locking? Explain the concept in detail.
The purpose of the @Version annotation in JPA is to define a version field on an entity that can be used for optimistic locking.

When an entity is updated in JPA, the persistence provider checks whether the version of the entity in the database matches the version of the entity in the persistence context. If the versions match, JPA updates the entity and increments the version number. If the versions do not match, it means that another transaction has modified the entity in the meantime, and JPA throws an optimistic locking exception.

The @Version annotation is used to mark a field on an entity as the version field. This field should be an integer. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------
JpaRepository is more powerful than other repository interfaces like CrudRepository because it adds:

Batch operations (e.g., delete multiple records at once)
Flush control (save and instantly write to the database)
Extra JPA features like saveAndFlush() and deleteInBatch()

Save and saveAndFlush
    save() → Saves the entity in memory (persistence context). It writes to the database later, usually when the transaction ends (commit time).
    saveAndFlush() → Saves the entity and immediately writes (flushes) it to the database.
--------------------------------------------------------------------------------------------------------------------------------------------------------------

JPA stands for Java Persistence API. It is an object-relational mapping (ORM) framework that allows us to map Java objects to tables in a relational database.
JPA is used to simplify the process of writing code for data persistence by providing a high-level abstraction layer over the underlying data storage technology, such as relational databases.

In JPA, an entity is a lightweight Java class that represents a persistent data object. Entities are used to map Java objects to database tables, where each entity corresponds to a row in the table.

Steps to Create a JPA Entity:
JPA entities are Java classes that can be mapped to database tables and these classes define the structure of the data and act as a bridge between the object-oriented world of Java and the relational world of the database

Define the java class and it can annotate it with the @Entity to mark it as an entity.
Define fields in the class to represent columns in the database table.
It can be annotated fields with the appropriate JPA annotations like @OneToOne and @OneToMany etc.
It can configure the data source and the persistence unit in the persistance.xml file.
It can use the EntityManager to perform the CRUD operations on the entities.

--------------------------------------------------------------------------------------------------------------------------------------------------------------
JPQL stands for Java Persistence Query Language. It is a platform-independent object-oriented query language that is used to retrieve data from a relational database using Java Persistence API. JPQL is similar to SQL (Structured Query Language) in terms of syntax, but instead of operating on tables and columns, it operates on JPA entities and their corresponding attributes.

String jpql = "SELECT e FROM Employee e WHERE e.department = :dept";

TypedQuery<Employee> query = entityManager.createQuery(jpql, Employee.class);
query.setParameter("dept", "IT");

List<Employee> results = query.getResultList();


--------------------------------------------------------------------------------------------------------------------------------------------------------------

A transaction in JPA ensures that a group of database operations are executed as a single unit:
    If all succeed → commit
    If any fail → rollback

import jakarta.persistence.*;
public class JpaTransactionExample {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("myJpaUnit");
        EntityManager em = emf.createEntityManager();

        EntityTransaction transaction = em.getTransaction();
        transaction.begin(); // Start transaction
        Employee emp = new Employee();
            emp.setName("John");
            em.persist(emp); // Insert operation

            emp.setSalary(60000); // Update operation
            em.merge(emp);

            transaction.commit(); // Commit transaction
            System.out.println("Transaction committed successfully!");
        } catch (Exception e) {
            if (transaction.isActive()) {
                transaction.rollback(); // Rollback if failure
                System.out.println("Transaction rolled back!");
            }
        } finally {
            em.close();
            emf.close();
        }
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------
@Transactional
It tells Spring that the method or class should run inside a transaction — if all operations succeed, it commits; if an exception occurs, it rolls back.

  If you put @Transactional at class level:
       All public methods inside the class will be transactional.
       Private, protected, or package-private methods are NOT transactional by default (they bypass proxies).
    Why Not Private?
        Spring uses proxy-based transaction management.
        Private methods cannot be proxied (they cannot be overridden).
        Only public (and optionally protected/package-private with AspectJ) can be intercepted.

How does it work with @Transactional?
    Spring creates a proxy object for your class (using JDK dynamic proxy or CGLIB).
    When you call a public method:
    Proxy starts a transaction.
    Executes your method.
    Commits if everything is fine, or rolls back on error.        
--------------------------------------------------------------------------------------------------------------------------------------------------------------
What are the advantages of using JPA over JDBC?

Object-Relational Mapping: It offers an Object-Relational Mapping (ORM) framework that enables developers to map Java objects to database tables without having to create SQL queries. Developers will have to write less code as a result, and the codebase will be simpler to maintain.

Portability: It is a standardized API that is independent of any specific database implementation. This means that applications written using JPA can be easily ported to different databases without having to rewrite the database access code.

Improved Performance: By minimizing the number of database queries that are run, it uses a caching mechanism that can enhance performance. This may lead to quicker response times and improved scalability.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
JPA Repository is an interface provided by Spring Data JPA that extends the JpaRepository interface. It provides a set of methods for performing common operations on entities, such as save, delete, findAll, and findById. In addition to these methods, it also allows you to define custom query methods using the @Query annotation.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
