Explain horizontal and vertical scaling in microservices?

Vertical Scaling (Scale Up)
    What it is: Make one server stronger.
    How: Add more CPU, RAM, or storage.
    Example:
            A microservice runs on a server with 4 CPU cores and 8 GB RAM.
            Vertical scaling ‚Üí Upgrade server to 8 CPU cores and 16 GB RAM.

Horizontal Scaling (Scale Out)
    What it is: Make more copies of the service.
    How: Run multiple instances and use a load balancer.
    Example:
            Microservice UserService runs on 1 instance.
            Horizontal scaling ‚Üí Deploy 3 more instances (total 4).
            A load balancer distributes requests among them.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
How do you ensure fault tolerance in microservices?
In microservices, fault tolerance means system keeps running even if some services fail.
    Retry mechanisms: Retry failed calls.
    Circuit breakers: Using libraries like Hystrix, Resilience4j.
    Fallbacks: Provide default responses.
    Bulkheads: Isolate resources for critical services.   
---------------------------------------------------------------------------------------------------------------------------------------------------------------
What is a service mesh in Microservices architecture?
A service mesh is an infrastructure layer that manages service-to-service communication, security, and observability in a microservices architecture without changing application code.
Tools like Istio, Linkerd, and Consul help manage traffic policies, security protocols, and observability without requiring changes to the application code.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you tell me about the 3C‚Äôs of Microservices?
The 3C‚Äôs of Microservices represent three essential pillars for building, managing, and scaling microservices effectively:
    Componentization ‚Äì Break the system into independent, business-focused services.
    Continuous Delivery ‚Äì Automate build, test, and deployment for frequent releases.
    Culture of DevOps ‚Äì Teams own the full lifecycle with collaboration and automation.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
JAR (Java ARchive): Packages libraries or standalone applications; contains classes, metadata, and resources. It can be executed directly with java -jar if it has a main class.

WAR (Web Application ARchive): Packages complete web applications; includes JSPs, HTML, and a WEB-INF folder for deployment to an external servlet container (e.g., Tomcat).

By default, Spring Boot creates a JAR (self-contained with embedded Tomcat/Jetty/Undertow).
WAR is used only when you want to deploy on an external server.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
How to Convert JAR to WAR in Spring Boot?
To convert a Spring Boot JAR to a WAR, I change the packaging to war, set Tomcat as provided, and extend SpringBootServletInitializer so it can run in an external servlet container. This is useful when migrating legacy systems that rely on shared servers, while JAR remains the preferred packaging for microservices.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Shadow Deployment?
Shadow deployment is a deployment strategy where a new version of a service runs in parallel with the existing (live) version, and receives real production traffic but does not impact real users. The new version processes the traffic in the background ("shadow mode"), and its responses are not returned to users.

Real-World Example
   Suppose you have an existing payment microservice and you developed a new version with optimized code. Instead of releasing it directly, you deploy it in shadow mode. The load balancer duplicates all real payment requests to this new version. It processes them and logs the results, but the actual payment transaction for customers is still handled by the old version. After monitoring for a week, if no critical issues appear, you gradually transition traffic to the new version.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Idempotency:
        Idempotency in microservices means no matter how many times you repeat the same request, the result will be the same, which makes systems safe and reliable.

Why it matters in microservices
    - In distributed systems, failures and retries are common (network timeouts, service crashes, etc.).
    - Without idempotency, retries could cause duplicate records, double billing, or data corruption.
    - Idempotency ensures safe retries and consistent state.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Eventual Consistency in microservices means data in different services may not match right away, but after a little time (when all updates are done), it will become consistent.

üëâ Example: When you place an order, the Order Service updates first, then after a short delay, the Payment and Inventory Services also update. For a moment things look different, but finally everything matches.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Retry in Microservices?
Retry is a resilience pattern that automatically re-attempts a failed operation in a microservices architecture. It is mainly used to handle transient failures like network timeouts, temporary service unavailability, or slow responses, without immediately failing the request.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Event-Driven Communication 
Event-Driven Communication is a way for different parts of a system (or microservices) to talk to each other by sending and listening to events instead of calling each other directly.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Distributed tracing helps track a single request as it flows through multiple microservices. It captures the full journey‚Äîincluding which services were called, how long each step took, and where any delays or errors occurred.

Tools like Zipkin and Jaeger make this visual by showing timelines and service maps.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Distributed Transaction?
A Distributed Transaction is a transaction that involves multiple services, databases, or systems working together, and it ensures that all operations succeed or all fail, even though they run on different machines.

-------------------------------------------------------------------------------------------------------------------------------------------------------------
Domain-Driven Design (DDD)
Domain-Driven Design is a software development approach that focuses on the business domain (the problem the software is solving) and organizes the code to match the business concepts, rules, and processes.

Key Points of Domain-Driven Design (DDD) 
    - Focus on the business problem, not just the tech.
    - Developers and business people use the same language to avoid confusion.
    - Break big systems into smaller, well-defined parts (Bounded Contexts).
    - Write code that matches real-world business concepts (like Customer, Order, Payment) using entities, value objects, and services.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Explain blue-green deployment in microservices.
Blue-green deployment is a release management strategy that reduces downtime and risk when deploying new versions of an application (or microservice).

Blue environment ‚Üí The current version of your microservice that‚Äôs live and serving traffic.
Green environment ‚Üí The new version of your microservice, fully deployed but not yet receiving real user traffic.

Two Environments:
    - Blue environment ‚Üí The current version of your microservice that‚Äôs live and serving traffic.
    - Green environment ‚Üí The new version of your microservice, fully deployed but not yet receiving real user traffic.
Deployment Steps:
    - Deploy the new version of the microservice to the green environment.
    - Test the green environment thoroughly (QA, integration tests, etc.).
    - Switch the traffic routing from blue to green (using a load balancer or API gateway).
    - If something goes wrong, roll back by routing traffic back to the blue environment.
Once Stable:
    - The green environment becomes the new ‚Äúblue‚Äù for the next deployment cycle.
    - The old blue environment can be updated for future releases.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Microservices Design Patterns for System Design:

1. Service Registry
Service Registry Pattern is a design pattern commonly used in microservices architecture to enable service discovery and dynamic load balancing. In this pattern, microservices register themselves with a service registry, which acts as a central repository for service metadata.
This metadata includes information such as service endpoint URLs, version numbers, and other configuration details.
Tool:
    Eureka (Netflix OSS)
    Consul (HashiCorp)

    - Eureka Server
      Eureka Server is an application that holds the information about all the microservices. Every Micro service will register into the Eureka server and Eureka server knows all the client applications running on each port and IP address. Eureka Server is also known as Discovery Server.
      The @EnableEurekaServer annotation is used to make your Spring Boot application acts as a Eureka Server.

------------------------------------------------------------------------
2. API Gateway
The API Gateway Pattern is a design pattern used in microservices.
An API gateway acts as a reverse proxy, sitting between client applications and the backend microservices.When its receives incoming requests, performs authentication (if enabled) and forwards requests to actual microservice. It provides a single entry point and hides the complexities of services in the backend.
Request routing
Authentication and authorization
Rate limiting
Load balancing
Logging & monitoring

Tool :
Netflix Zuul,Spring Cloud Gateway,Kong,NGINX
------------------------------------------------------------------------
3. Circuit Breaker
Circuit Breaker is design pattern in microservices is like a safety mechanism that prevents one broken part from bringing down the whole system. It detects when a service is not working correctly and stops sending requests to it temporarily. This helps keep the rest of the system running smoothly and prevents problems from spreading. Once the broken part is fixed, it allows requests to flow again.

How It Works
Closed State: Initially, the circuit is closed, and requests flow normally. The Circuit Breaker monitors the success and failure rates of the requests.

Open State: If the failure rate exceeds a certain threshold, the circuit opens. This means that any requests to the failed service are immediately returned with an error, without actually attempting to call the service. This helps to avoid overwhelming the failing service.

Half-Open State: After a predefined timeout period, the Circuit Breaker enters a half-open state and allows a limited number of test requests to pass through. If these requests succeed, the circuit closes again, and normal operation resumes. If they fail, the circuit reopens.

Tools
Netflix Hystrix,Resilience4j,Spring Cloud Circuit Breaker

Example
Imagine you have a web application that relies on several microservices. One of these services handles user authentication. Now, if this authentication service suddenly becomes slow or stops responding due to high traffic or a technical issue:

Without Circuit Breaker: Every time a user tries to log in or access a secure page, your application continues to send requests to the authentication service, even though it's not responding properly. This can slow down your entire application and potentially make it unusable for all users.
With Circuit Breaker: The Circuit Breaker monitors the requests to the authentication service. When it detects that too many requests are failing or taking too long:
It "opens" the circuit, meaning it stops sending requests to the authentication service temporarily.
Your application can then handle these situations gracefully, such as showing a friendly error message to users trying to log in.
After a set period, the Circuit Breaker may allow a few test requests to see if the authentication service has recovered.
If the service is working again, the Circuit Breaker "closes" and resumes sending requests normally.
If the service is still problematic, the Circuit Breaker remains open to prevent further issues and protect the rest of your application.
------------------------------------------------------------------------
4. Saga Pattern
The Saga Pattern is used to manage distributed transactions across microservices. Each service executes a local transaction and publishes an event. If any service in the sequence fails, compensating transactions are executed to undo previous steps.(Compensating action = business-defined undo step.)

   Approaches to Implemement SAGA Design Pattern.
     1 Choreography-Based Approach (Event-Driven)
       - There is no central coordinator; each service knows what to do next and triggers the next step by emitting events.
       - Services communicate through events (e.g., via message queues or event streams). Each service listens for events and performs its own action when the   event occurs.
       - Services operate independently and don‚Äôt need to know about each other‚Äôs details, just the events they need to react to.
       - If a service fails, it publishes a failure event, and other services can listen to it and perform compensating actions.
     Example:
            Order Service creates an order and publishes the "OrderCreated" event.
            Payment Service listens for "OrderCreated" and processes payment, publishing "PaymentProcessed".
            Inventory Service listens for "PaymentProcessed" and updates inventory, and so on.

    2. Orchestration-Based Approach (Centralized)
       - There is central coordinator;  controls the flow of the entire saga.
       - The orchestrator tells each service when to start, what to do, and when to proceed to the next step.
       - The orchestrator has detailed knowledge of each service and their responsibilities in the saga.
       - The orchestrator manages failure recovery and calls the compensating actions if needed.

------------------------------------------------------------------------
5. CDC (Consumer-Driven Contracts)
    It‚Äôs a way for two systems (consumer and provider) to agree on how they talk to each other (API contract).
    The consumer (client) defines what it needs from the provider (server).
    These needs are saved as a contract (like a rule book).
    Every time the provider changes its API, this contract is automatically tested to make sure nothing breaks for the consumer.
OR
Consumer-Driven Contracts are agreements between API consumers and providers, driven by the consumer‚Äôs needs, verified automatically to ensure changes don‚Äôt break communication.

Example:
    Your frontend app (consumer) needs /users API to give name and email.
    You create a contract saying: ‚ÄúI need name and email fields.‚Äù
    Backend (provider) must follow this contract.
    If backend removes email by mistake, tests fail ‚Üí you catch the issue early.
------------------------------------------------------------------------
6. Bulkhead Pattern
A way to isolate parts of a system so if one fails or slows down, it doesn‚Äôt sink the whole system.
In microservices, bulkhead pattern means isolating resources (like threads, database connections, memory) for each part of the system so a failure in one part doesn‚Äôt bring down others.
Example:
    If the Payment Service gets overloaded, only payment-related requests fail, while Order Service and Inventory Service keep running normally.
------------------------------------------------------------------------
7. Event Sourcing 
Instead of storing just the current state of data, you store all the events that happened to reach that state.
The current state can be rebuilt anytime by replaying those events.

Example :
    Imagine a Bank Account Service:
        Traditional way (state storage):
        Balance = ‚Çπ1000 (you just store the current balance).

    Event Sourcing way:
        Events stored:
        Account Created with ‚Çπ1000
        Deposited ‚Çπ500
        Withdrawn ‚Çπ200
        Current balance = ‚Çπ1000 + ‚Çπ500 - ‚Çπ200 = ‚Çπ1300
        So instead of only storing the balance, you store the events that led to it.
------------------------------------------------------------------------
8. Data Sharding
In microservices design patterns, Data Sharding is used to make each microservice‚Äôs database faster and more scalable by splitting large datasets into smaller, manageable parts (shards) stored on different database instances.
------------------------------------------------------------------------
9. Command-Query Responsibility Segregation
Command-Query Responsibility Segregation (CQRS) means separating ‚Äúwrite‚Äù operations (commands that change data) from ‚Äúread‚Äù operations (queries that only fetch data) so both can be handled and optimized differently.

OR
CQRS is an architectural pattern where the operations that read data (queries) are separated from those that modify data (commands). This approach helps to optimize read and write operations, especially in complex applications where the requirements

üëâ Command = change data
üëâ Query = read data
------------------------------------------------------------------------
10 What is the Sidecar pattern in Microservices?
The Sidecar pattern is a design pattern where a support service runs alongside a main microservice in the same environment (usually the same container or pod).
It offloads common concerns logging, monitoring, security, or networking from the main service.

Example Use Cases
Logging/Monitoring: A sidecar collects logs and metrics and forwards them to a central system.
Network Proxy: A sidecar handles service discovery, load balancing, and TLS for the main service.
Configuration Updates: Dynamically fetches configuration from a central server.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Load balancer
Load balancer in microservices ‚Üí A tool that spreads incoming requests across multiple instances of a microservice so no single instance gets overloaded, ensuring better performance, reliability, and availability
Examples
HAProxy: A popular open-source tool that balances load across services.
NGINX: A web server that also provides load balancing capabilities.

Scenario
User Requests: Multiple users are browsing your online store, placing orders, and managing their accounts simultaneously.

Product Service Instances: You have three instances of the Product Service running to manage the traffic (e.g., Product Service A, Product Service B, Product Service C).

How the Load Balancer Works
Distributing Requests: When a user requests product details, the load balancer receives the request and distributes it to one of the three Product Service instances (e.g., it sends the first request to Product Service A, the second to Product Service B, and so on).

Health Monitoring: The load balancer regularly checks if each Product Service instance is running properly. If Product Service B crashes, the load balancer stops sending requests to it and only uses Product Service A and Product Service C.

Scaling: During a big sale event, traffic spikes. You can add more instances of the Product Service (e.g., Product Service D and Product Service E). The load balancer will automatically start distributing requests to these new instances as well.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you handle distributed transactions in microservices?
Saga Pattern ‚Äì Break big transactions into smaller local transactions.
        - Choreography: Services react to each other‚Äôs events.
        - Orchestration: A central coordinator tells services what to do.

Two-Phase Commit (2PC) in microservices is a distributed transaction protocol that ensures all services either commit or rollback together so data stays consistent.

How It Works
Prepare Phase
    A coordinator asks all services: ‚ÄúCan you commit?‚Äù
    Each service locks resources and replies YES or NO (without committing yet).
Commit Phase
    If all say YES ‚Üí Coordinator sends COMMIT ‚Üí All services commit changes.
    If any say NO ‚Üí Coordinator sends ROLLBACK ‚Üí All services undo changes.        
---------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the difference between service registry and service discovery in microservices?

Service Registry ‚Üí A directory/phonebook where all microservices register their addresses (IP + port).
Service Discovery ‚Üí The process of finding a service‚Äôs address from that directory so services can talk to each other.

Analogy:

Service Registry = Phonebook
Service Discovery = Looking up a friend‚Äôs number and calling them
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Explain the Strangler Pattern.
A migration strategy where you gradually replace parts of a legacy (monolithic) system with a new microservices-based system, instead of rewriting everything at once.
The old system and the new system co-exist until the legacy parts are fully replaced.

How It Works
    Put a proxy or API gateway in front of the legacy system.
    Route some requests to the new microservice, and the rest still go to the legacy system.
    Gradually move features from the old system to microservices.
    Once everything is migrated, the legacy system can be ‚Äústrangled‚Äù (retired).
-------------------------------------------------------------------------------------------------------------------------------------------------------------
How does the CAP theorem relate to a microservices architecture?
In any distributed system (like microservices), you can only guarantee 2 out of 3:
Consistency (C): All services see the same data at the same time.
Availability (A): Every request gets a response, even if some services are down.
Partition Tolerance (P): System still works even if there are network issues between services.

Since network problems (P) will always happen, microservices must choose:
    CP (Consistency + Partition Tolerance): Correct data, but sometimes not available.
        Example: Banking ‚Äì better to block a transaction than show wrong balance.
    AP (Availability + Partition Tolerance): Always available, but data may be slightly out of sync.
        Example: Shopping site catalog ‚Äì OK if product count is a bit old.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
What are the common challenges in implementing microservices?

Implementing microservices comes with several challenges:
    - Service Communication ‚Äì Managing synchronous (REST) vs asynchronous (events) communication.
    - Data Consistency ‚Äì Each service has its own database, making distributed transactions complex.
    - Deployment & Operations ‚Äì Managing many services increases CI/CD, container orchestration, and infrastructure complexity.
    - Testing ‚Äì End-to-end and integration testing are more difficult compared to monoliths.
    - Security ‚Äì Enforcing authentication and authorization across multiple services.
    - Observability ‚Äì Requires centralized logging, distributed tracing, and monitoring.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
How do you handle error handling in a microservices-based system?
   In microservices, error handling is done at multiple levels:
   - At the service level, using global exception handling and proper HTTP status codes.
   - Between services, using resilience patterns like retries, circuit breakers, fallbacks, and timeouts.
   - For asynchronous communication, handling failures with dead-letter queues, retries, and idempotency.
   - At the system level, using centralized logging, distributed tracing, and monitoring to quickly detect and resolve errors.‚Äù
------------------------------------------------------------------------------------------------------------------------------------------------------------- 
How would you ensure data consistency across multiple microservices?
We use patterns like Saga (orchestration or choreography) to manage business transactions, and event-driven communication to propagate changes. Idempotency ensures safe retries, and for queries, we can use API composition to combine data from multiple services. Together, these approaches keep data consistent while maintaining scalability and resilience.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you explain how you would handle cross-cutting concerns like logging, authentication, and authorization in a microservices environment?
‚ÄúIn a microservices environment, cross-cutting concerns like logging, authentication, and authorization are handled in a centralized and consistent way. For logging and monitoring, I use centralized logging (ELK/EFK) and distributed tracing (Zipkin/Jaeger). For authentication and authorization, I rely on OAuth2 + JWT managed by a centralized identity provider, with validation at the API Gateway. I also use service mesh or AOP techniques for consistent policies. This ensures each microservice stays focused only on business logic, while cross-cutting concerns are managed in a unified way.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you explain how to manage distributed transactions with the Saga pattern?
The Saga pattern manages distributed transactions by breaking them into a series of local transactions in each service. If one step fails, compensating transactions undo the previous steps. There are two approaches: Choreography (event-driven, decentralized) and Orchestration (central coordinator). This ensures eventual consistency without relying on 2PC.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the 12-factor app methodology?
The 12-Factor App methodology is a set of best practices for building modern, scalable, and maintainable Software-as-a-Service (SaaS) applications. It was introduced by Heroku to help developers design applications that are portable, resilient, and easy to deploy across different environments (development, staging, production, etc.).

Mnemonic: "Cool Developers Build Bright Projects, Providing Clever, Clean, Deep Logs And Apps"
A-1 ,B - 2 ,CCC-3 , D-3 , L-1 , p-2
1  Admin Processes - Run admin tasks as one-off processes ‚Äì Execute migrations, scripts, and maintenance tasks separately.
2  Backing Services -  Treat services as attached resources ‚Äì Databases, queues, and caches should be swappable without changing code.
3  Build, Release, Run - Separate build, release, and run ‚Äì Ensure builds are immutable and configuration is applied only at release.
4  Codebase - One codebase, many deploys ‚Äì A single version-controlled codebase is used for multiple deployments (dev, staging, prod).
5  Config - Store config in the environment ‚Äì Keep credentials, URLs, and keys outside the codebase using environment variables.
6  Concurrency - Scale by process model ‚Äì Scale horizontally by adding more processes, not by creating threads inside one.  
7  Dependencies - Explicitly declare dependencies ‚Äì Use a dependency manager to avoid hidden, system-level dependencies.
8  Disposability - Fast start, graceful shutdown ‚Äì Processes should boot quickly and handle termination signals properly.
9  Dev/Prod Parity - Keep environments similar ‚Äì Minimize differences between development, staging, and production.
10 Logs - Treat logs as event streams ‚Äì Output logs to stdout/stderr and let the environment handle aggregation.
11 Processes - Execute as stateless processes ‚Äì Do not store session or data in-process; use external storage.
12 Port Binding - Export services via port binding ‚Äì The app should run independently by exposing HTTP or other services on a port.
 -------------------------------------------------------------------------------------------------------------------------------------------------------------
Maven is a build automation and project management tool primarily used for Java projects. It uses a project object model (POM) file to manage project dependencies, build processes, and project documentation. Maven simplifies the build process by providing a standard way to handle project configuration, dependencies, and plugins.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Monolithic and Microservices Architecture

Monolithic
A monolithic architecture is a traditional approach to designing software where an entire application is built as a single, indivisible unit. In this architecture, all the different components of the application, such as the user interface, business logic, and data access layer, are tightly integrated and deployed together.

1 Monolithic architecture is built as one large system and is usually one code-base
2 It is not easy to scale based on demand
3 It has shared database
4 Large code base makes IDE slow and build time gets increase.
5 Small changes introduce greater risks as they impact the entire code base.
6 Entire application deployed as a single entity.


Microservices
In a microservices architecture, an application is built as a collection of small, independent services, each representing a specific business capability. These services are loosely coupled and communicate with each other over a network, often using lightweight protocols like HTTP or messaging queues.

1 Microservices architecture is built as small independent module based on business functionality
2 It is easy to scale based on demand.
3 Each project and module has their own database.
4 Each project is independent and small in size.So overall build and development time gets decrease.
5 You can modify individual microservices without impacting the entire application.
6 Every microservice is an independent software entity that requires individual containerized deployment.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
FeignClient

Feign is one of the best HTTP clients which we could use with Spring boot to communicate with third-party REST APIs.
@EnableFeignClients‚Äô annotation in the main class.

then we can start creating the interface which will act as the client for this API. To do that we just need to create an interface inside the project.

@FeignClient(value = "instantwebtools-api", url = "https://api.instantwebtools.net/v1/")
public interface ApiClient {

    @RequestMapping(method = RequestMethod.GET, value = "/airlines")
    List<Airline> readAirLines();

    @RequestMapping(method = RequestMethod.GET, value = "/airlines/{airlineId}")
    Airline readAirLineById(@PathVariable("airlineId") String airlineId);

}
---------------------------------------------------------------------------------------------------------------------------------------------------------------
WebClient

Spring WebClient is a non-blocking and reactive web client to perform HTTP requests. It is also the replacement for the classic RestTemplate. It is a part of spring-webflux library and also offers support for both synchronous and asynchronous operations. The DefaultWebClient class implements this WebClient interface.

@Autowired
private WebClient webClient;

AddressResponse addressResponse = webClient.get().uri("/address/" + id).retrieve().bodyToMono(AddressResponse.class).block();
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Two-factor authentication (2FA) is a security process that requires users to verify their identity using two different authentication factors before gaining access to an online account. This additional layer of security helps protect against unauthorized access resulting from compromised credentials. Passwords are often easy to guess or steal, and many users reuse the same password for multiple accounts. By requiring a second factor, 2FA can help prevent unauthorized access even if a user‚Äôs password is compromised.

Different Types of 2FA
SMS-based Verification: Upon successful entry of their password, the user receives a code via text message that they must enter to gain access.
Email-based Verification: Similar to SMS, a code is sent to the user‚Äôs email address and must be entered on the site to complete the authentication process.
Authenticator Apps: Applications like Google Authenticator or Authy generate time-limited codes that sync with the server time to provide a code that can be used for the second factor

-------------------------------------------------------------------------------------------------------------------------------------------------------------.
Swagger is an open-source API design and documentation tool that helps developers design, build, document, and test RESTful APIs faster and more easily.
Swagger is the way of defining the structure of APIs (Application Programming Interface). Swagger is specifically developed for REST (Representational State Transfer) APIs, where REST is a Web based API. These APIs can be defined in a file, called Swagger file, which includes certain information like the type of data that needs to be sent in a request, the type of data that needs to be received as the response from the request sent, the server locations, authorization for the request, status codes etc. The Swagger Specification is also known as the Open API Specification (OAS). Using swagger, APIs can be created in either YAML or JSON. The different tools used for swagger are: Swagger Editor, Swagger UI and Swagger Codegen. The latest version of OAS is OpenAPI 3.0.

<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.5.0</version>
</dependency>

Url:
http://localhost:8080/swagger-ui/index.html

---------------------------------------------------------------------------------------------------------------------------------------------------------------
SonarQube
SonarQube is a powerful tool for continuous inspection of code quality and security. It performs static code analysis to detect bugs, code smells, and security vulnerabilities in your project. Integrating SonarQube with a Spring Boot application involves setting up SonarQube, configuring your Spring Boot project to use SonarQube, and running the analysis.
------------------------------------------------------------------------------------------------------------------------------------------------------------

